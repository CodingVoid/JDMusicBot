/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Discord.Ducktales.Bot;

import com.sedmelluq.discord.lavaplayer.player.AudioPlayer;
import com.sedmelluq.discord.lavaplayer.player.AudioPlayerManager;
import com.sedmelluq.discord.lavaplayer.player.DefaultAudioPlayerManager;
import com.sedmelluq.discord.lavaplayer.source.AudioSourceManagers;

//import org.discordbots.api.client.DiscordBotListAPI;
//import org.discordbots.api.client.DiscordBotListAPI.Builder;

import discord4j.core.DiscordClient;
import discord4j.core.DiscordClientBuilder;
import discord4j.core.event.domain.lifecycle.ReadyEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.VoiceState;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.VoiceChannel;
import discord4j.voice.AudioProvider;

public class App {

	private static final DiscordClient client = new DiscordClientBuilder("Mjg3MzI4MzU5Njc4MjE0MTU1.XayxVg.OOMDFgF66DVClhe_HTBfThB5_cA").build();
	public static void main(String[] args) {
		/*
		   DiscordBotListAPI api = new Builder()
		   .token("OeUB7zCt8ITuPF-5yfa1ALUhbrMNR-qk")
		   .botId("287328359678214155")
		   .build();
		   */
		client.getEventDispatcher().on(ReadyEvent.class)
			.subscribe(ready -> System.out.println("Logged in as " + ready.getSelf().getUsername()));

		client.getEventDispatcher().on(MessageCreateEvent.class)
			.subscribe(event -> handleMsg(event));

		/* Lavaplayer */
		playerManager = new DefaultAudioPlayerManager();
		AudioSourceManagers.registerRemoteSources(playerManager);

		AudioPlayer player = playerManager.createPlayer();

		/* Register our TrackScheduler that is receiving all audio events from lavaplayer (like events for starting or ending tracks). It makes sense to also make it responsible for scheduling tracks */
		trackScheduler = new TrackScheduler(player);
		player.addListener(trackScheduler);

		/* Link Discord4j and Lavaplayer together */
		provider = new LavaPlayerAudioProvider(player);

		client.login().block();
	}
	
	private static AudioProvider provider;

	private static AudioPlayerManager playerManager;
	private static TrackScheduler trackScheduler;

	private static void handleMsg(MessageCreateEvent event) {
		Message msg = event.getMessage();
		if (msg.getContent().map("!ping"::equals).orElse(false)) {
			msg.getChannel().block().createMessage("Pong!").block();
		}
		if (msg.getContent().map("!join"::equals).orElse(false)) {
			final Member member = event.getMember().orElse(null);
			if (member != null) {
				final VoiceState voiceState = member.getVoiceState().block();
				if (voiceState != null) {
					final VoiceChannel channel = voiceState.getChannel().block();
					if (channel != null) {
						// join returns a VoiceConnection which would be required if we were
						// adding disconnection features, but for now we are just ignoring it.
						channel.join(spec -> spec.setProvider(provider)).block();
					}
				}
			}
		}
		if (msg.getContent().map("!test"::equals).orElse(false)) {
			msg.getChannel().block().createMessage("playing").block();
			playerManager.loadItem("https://www.youtube.com/watch?v=fzQ6gRAEoy0", trackScheduler);
		}
	}
}
