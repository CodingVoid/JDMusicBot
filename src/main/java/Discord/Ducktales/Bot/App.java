/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Discord.Ducktales.Bot;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import com.sedmelluq.discord.lavaplayer.player.AudioPlayer;
import com.sedmelluq.discord.lavaplayer.player.AudioPlayerManager;
import com.sedmelluq.discord.lavaplayer.player.DefaultAudioPlayerManager;
import com.sedmelluq.discord.lavaplayer.source.AudioSourceManagers;

//import org.discordbots.api.client.DiscordBotListAPI;
//import org.discordbots.api.client.DiscordBotListAPI.Builder;

import discord4j.core.DiscordClient;
import discord4j.core.DiscordClientBuilder;
import discord4j.core.event.domain.lifecycle.ReadyEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.VoiceState;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.MessageChannel;
import discord4j.core.object.entity.VoiceChannel;
import discord4j.voice.AudioProvider;
import discord4j.voice.VoiceConnection;
import reactor.core.publisher.Mono;

public class App {

	private static Logger logger = new Logger("Command-Logger");
	private static final DiscordClient client = new DiscordClientBuilder("Mjg3MzI4MzU5Njc4MjE0MTU1.XayxVg.OOMDFgF66DVClhe_HTBfThB5_cA").build();
	public static void main(String[] args) {
		/*
		   DiscordBotListAPI api = new Builder()
		   .token("OeUB7zCt8ITuPF-5yfa1ALUhbrMNR-qk")
		   .botId("287328359678214155")
		   .build();
		   */
		client.getEventDispatcher().on(ReadyEvent.class)
			.subscribe(ready -> System.out.println("Logged in as " + ready.getSelf().getUsername()));

		client.getEventDispatcher().on(MessageCreateEvent.class)
			.subscribe(event -> handleMsg(event));

		/* Lavaplayer */
		playerManager = new DefaultAudioPlayerManager();
		AudioSourceManagers.registerRemoteSources(playerManager);

		AudioPlayer player = playerManager.createPlayer();

		/* Register our TrackScheduler that is receiving all audio events from lavaplayer (like events for starting or ending tracks). It makes sense to also make it responsible for scheduling tracks */
		trackScheduler = new TrackScheduler(player);
		player.addListener(trackScheduler);

		/* Link Discord4j and Lavaplayer together */ provider = new LavaPlayerAudioProvider(player);

		/* Initialize Command Queue */
		initializeCommands();


		client.login().block();
	}

	private static AudioProvider provider;

	private static AudioPlayerManager playerManager;
	private static TrackScheduler trackScheduler;

	private static void handleMsg(MessageCreateEvent event) {
		/* Set Bot Output Channel for more Output */
		trackScheduler.setOutputChannel(event.getMessage().getChannel().block());

		final String content = event.getMessage().getContent().orElse("");
		for (final Map.Entry<String, CommandInfo> entry : commands.entrySet()) {
			if (content.startsWith(entry.getKey())) {
				entry.getValue().cmd.execute(event);
				break;
			}
		}

	}

	private static Map<String, CommandInfo> commands = new HashMap<String, CommandInfo>();

	/* Holds the currently active Connection to a Voice-Chat and is being used to disconnect from a Voice-Channel */
	private static VoiceConnection con;

	private static void initializeCommands() {
		/* !help Command */
		commands.put("!help", new CommandInfo("!help", "Show the Help Message", event -> {
			MessageChannel channel = event.getMessage().getChannel().block();
			StringBuilder builder = new StringBuilder();
			for (final Map.Entry<String, CommandInfo> entry : commands.entrySet()) {
				CommandInfo info = entry.getValue();
				builder.append("Command/Usage: ");
				builder.append(info.usage);
				builder.append("\nDescription: ");
				builder.append(info.description);
				builder.append("\n\n");
			}
			channel.createMessage(builder.toString()).block();
		}));
		
		/* !ping Command */
		commands.put("!ping", new CommandInfo("!ping", "get yourself a pong", event -> {
			event.getMessage().getChannel().block().createMessage("Pong!").block();
		}));

		/* !join Command */
		commands.put("!join", new CommandInfo("!join", "let Ducktales Bot join your voice channel", event -> {
			final Member member = event.getMember().orElse(null);
			if (member != null) {
				final VoiceState voiceState = member.getVoiceState().block();
				if (voiceState != null) {
					final VoiceChannel channel = voiceState.getChannel().block();
					if (channel != null) {
						logger.debug("At !join Command: Try to Join VoiceChannel");
						channel.join(spec -> spec.setProvider(provider)).block(Duration.ofSeconds(2));
						logger.debug("At !join Command: Tried to Join VoiceChannel. Either Successed or is timed out.");
					}
				}
			}
		}));
		
		/* !play Command */
		commands.put("!play", new CommandInfo("!play [youtube-video-link or Soundcloud or ...]", "Let the Ducktales Bot join your voice channel and append audio to the video queue", event -> {
			final Member member = event.getMember().orElse(null);
			if (member != null) {
				final VoiceState voiceState = member.getVoiceState().block();
				if (voiceState != null) {
					final VoiceChannel channel = voiceState.getChannel().block();
					if (channel != null) {
						logger.debug("At !play Command: Get VoiceChannel of Ducktales Bot");
						//VoiceChannel schan = client.getSelf().block().asMember(channel.getGuildId()).block().getVoiceState().block().getChannel().block();
						VoiceChannel schan = client.getSelf().flatMap(user -> user.asMember(channel.getGuildId())).flatMap(mem -> mem.getVoiceState()).flatMap(vstate -> vstate.getChannel()).block();
						logger.debug("At !play Command: Check if Ducktales Bot is already in the VoiceChannel");
						if (!channel.equals(schan)) {
							/* If you are not in the voice channel of the caller, join the voice channel */
							logger.debug("At !play Command: Join VoiceChannel");
							App.con = channel.join(spec -> spec.setProvider(provider)).block();
						}
						else {
							logger.debug("At !play Command: Ducktales Bot already in the VoiceChannel");
						}
						logger.debug("At !play Command: Load Audio-Track");
						String url = event.getMessage().getContent().get().split(" ")[1];
						playerManager.loadItem(url, trackScheduler);
					}
				}
			}
		}));
		commands.put("!stop", new CommandInfo("!stop", "Stop the currently playing audio", event -> {
		}));

		commands.put("!test", new CommandInfo("!test", "Test", event -> {
			MessageChannel channel = event.getMessage().getChannel().block();
			channel.createMessage("playing").block();
			client.getGuilds().collectList().block().forEach(guild -> channel.createMessage("Group: " + guild.getId().asString()).block());
			client.getGuilds().collectList().block().forEach(guild -> channel.createMessage("Group: " + guild.getName()).block());
			channel.createMessage("Self-ID: " + client.getSelfId().get().asString()).block();
			channel.createMessage("playing2").block();
			playerManager.loadItem("https://www.youtube.com/watch?v=fzQ6gRAEoy0", trackScheduler);
		}));
		commands.put("!leave", new CommandInfo("!leave", "Tell the Ducktales Bot to leave it's current voice-channel", event -> {
			if (con != null) {
				logger.debug("At !leave Command: Disconnect from VoiceChannel");
				con.disconnect();
			}
			else {
				logger.debug("At !leave Command: Bot is not in a VoiceChannel");
			}
		}));
	}
}
